# 1. Уровни веб-приложения
##  
   - Уровень представления (PL)
   - Уровень обслуживания данных (DSL)
   - Уровень бизнес-логики (BLL)
   - Уровень доступа к данным (DAL)

# 2. За что отвечает каждый из уровней веб-приложений
##
   - уровень представления.
   Отображает пользовательский интефейс и упрощает взаимодействие с пользователем. Уровень представления имеет компоненты пользовательского интерфейса, которые визуализируют и показываю данные для пользователей. Также существуют компоненты пользовательского процесса, которые задают взаимодествие с пользователем. PL предоставляет всю необходимую информацию клиентской стороне. Основная цель уровня представления- получить входные данные, обработать запросы пользователей, отправить их в службу данных и показать результаты.
   - уровень обслуживания данных. DSL передает данные, обработанные уровнем бизнес-логики, на уровень представления. Этот уровень гарантирует безопасность данных, изолируя бизнес-логику со стороны клиента.
   - уровень бизнес-логики. BLL несет ответственность за надлежащий обмен данными. Этот уровень определяет логику бизнес-операций и правил. Вход на сайт- это пример уровня бизнес-логики.
   - уровень доступа к данным. DAL предлагает упрощенный доступ к данным, хранящимся в постоянных хранилищах, таких как двоичные файлы и файлы XML. Уровень доступа к данным также управляет операциями CRUD- создание, чтение, обновление, удаление.
# 3. Монолитная архитектура веб-приложения
##
   - Монолитная архитектура представляет собой единый модуль, работающий автономно, независимо от других приложений. 
# Микросервисная архитектура веб-приложения
   - Микросервисы- вариант сервис-ориентированной архитертуры ПО, который обеспечивает взаимодействие независимых друг от друга небольших, слабо связанных и легко изменяемых модулей.
# 4. Различия между монолитом и микросервисами
     Традиционная монолитная архитектура веб-приложения состоит из тех частей-базы данных, клиентской и серверной сторон( внутренняя и внешняя логика, как и др. фоновые задачи,генерируются в одной кодовой базе). Чтобы изменить или обновить компонент приложения, разработчики программного обеспечения должны переписать все приложения. Что касается микросервисов, этот подход позволяет разработчикам создавать веб-приложение из набора небольших сервисов. Разработчики создают и развертывают каждый компонент отдельно.
 ***Преимущества монолитной архитектуры***

    - Простое развертывание. Использование одного исполняемого файла или каталога упрощает развертывание.

    - Разработка. Приложение легче разрабатывать, когда оно создано с использованием одной базы кода.

    - Производительность. В централизованной базе кода и репозитории один интерфейс API часто может выполнять ту функцию, которую при работе с микросервисами выполняют многочисленные API.

    - Упрощенное тестирование. Монолитное приложение представляет собой единый централизованный модуль, поэтому сквозное тестирование можно проводить быстрее, чем при использовании распределенного приложения.

    - Удобная отладка. Весь код находится в одном месте, благодаря чему становится легче выполнять запросы и находить проблемы.
***Недостатки монолитной архитектуры***

    - Снижение скорости разработки. Большое монолитное приложение усложняет и замедляет разработку.

    - Масштабируемость. Невозможно масштабировать отдельные компоненты.

    - Надежность. Ошибка в одном модуле может повлиять на доступность всего приложения.

    - Препятствия для внедрения технологий. Любые изменения в инфраструктуре или языке разработки влияют на приложение целиком, что зачастую приводит к увеличению стоимости и временных затрат.

    - Недостаточная гибкость. Возможности монолитных приложений ограничены используемыми технологиями.

    - Развертывание. При внесении небольшого изменения потребуется повторное развертывание всего монолитного приложения.
***Преимущества микросервисов***

    - Гибкость. Продвигайте гибкие методы работы среди небольших команд, которые регулярно выполняют развертывание.

    - Гибкое масштабирование. Когда микросервис достигает предельной нагрузки, можно быстро выполнить развертывание новых экземпляров данной службы в сопутствующем кластере и снизить нагрузку. Теперь мы работаем с несколькими держателями и без сохранения состояния, а клиенты распределены по различным экземплярам. С таким подходом мы можем поддерживать экземпляры гораздо большего размера.

    - Непрерывное развертывание. Теперь у нас есть регулярные и ускоренные циклы релиза. Раньше мы выпускали обновления раз в неделю, а теперь можем делать это примерно два-три раза в день.

    - Легкость обслуживания и тестирования. Команды могут экспериментировать с новыми функциями и возвращаться к предыдущей версии, если что-то не работает. Это упрощает обновление кода и ускоряет выпуск новых функций на рынок. Кроме того, в отдельных службах легко находить и исправлять ошибки и баги.

    - Независимое развертывание. Микросервисы представляют собой отдельные модули, поэтому с ними можно легко и быстро выполнять независимое развертывание отдельных функций.

    - Гибкость технологий. При использовании архитектуры микросервисов команды могут выбирать инструменты с учетом своих предпочтений.

    - Высокая надежность. Развертывая изменения для конкретной службы, можно не бояться, что приложение выйдет из строя целиком.

***Недостатки микросервисов***

    - Разрастание процесса разработки. Микросервисы усложняют работу по сравнению с монолитной архитектурой, поскольку в различных местах возникает все больше служб, созданных несколькими командами. Если разрастание не контролируется должным образом, оно приводит к замедлению разработки и снижению операционной эффективности.

    - Экспоненциальный рост расходов на инфраструктуру. У каждого нового микросервиса может быть своя стоимость комплекта тестов, инструкций по развертыванию, инфраструктуры хостинга, инструментов мониторинга и т. д.

    - Дополнительные организационные расходы. Командам требуется дополнительный уровень коммуникации и сотрудничества, чтобы координировать работу над обновлениями и интерфейсами.
    - Проблемы при отладке. У каждого микросервиса свой набор журналов, что усложняет отладку. Кроме того, дополнительные затруднения могут возникать в том случае, когда один бизнес-процесс выполняется на нескольких машинах.
    - Отсутствие стандартизации. Без общей платформы может возникнуть ситуация, в которой расширяется список языков, стандартов ведения журналов и средств мониторинга.
    - Отсутствие ясности в вопросах владения. По мере появления новых служб увеличивается и количество работающих над ними команд. Со временем становится сложнее определить, какие службы команда может использовать и к кому следует обращаться за поддержкой. 
# 5. Почему не все приложения построены на микросервисной архитектуре

 ***Сложнее осуществить мониторинг***. Микросервисов сотни, а иногда тысячи, и уследить за каждым физически невозможно. Поэтому приходится уделять много внимания системам управления и мониторинга.
 ***Каждый микросервис может использовать тот язык программирования и те технологии, что удобны команде, которая его разрабатывает***. С одной стороны, это плюс — какие-то фреймворки и языки лучше заточены под конкретные вещи. Если мы делаем сервис обработки изображений или машинного обучения, можем не заострять внимание на технологиях монолита, а выбрать решение под задачу. С другой стороны, это минус — нужно как-то конфигурировать все микросервисы между собой и поддерживать «зоопарк» технологий. 
 ***Снижение доверия***. Когда у нас сотни узлов, могут возникать проблемы с аутентификацией и авторизацией, поскольку есть вероятность подсоединения мошенников. 
 ***Сложности развёртывания***. Чтобы требования по отказоустойчивости выполнялись, микросервисы нужно развёртывать на отдельных серверах. И здесь не работает подход: «Берём приложение, ставим и запускаем». Нужны системы оркестрации и деплоймента. 
# 6. Каковы особенности тестирования монолитных и микросервисных веб-приложений

Несмотря на свою простоту, монолитное решение с одним проектом имеет определенные недостатки. По мере увеличения размера и сложности проекта будет расти число файлов и папок. Задачи, связанные с пользовательским интерфейсом (модели, представления, контроллеры), размещаются в разных папках, которые не упорядочены по алфавиту. С добавлением в отдельные папки конструкций уровня пользовательского интерфейса, например фильтров или связывателей модели, ситуация только ухудшается. Для решения подобных проблем приложения часто организуются в виде решений, состоящих из множества проектов, где каждый проект размещается в отдельном слое приложения.
Помимо возможности замены реализаций в связи с последующими изменениями, применение слоев в приложении также позволяет менять реализации в целях тестирования. Вместо написания тестов, которые применяются к слоям реальных данных или пользовательского интерфейса приложения, во время тестирования они заменяются фиктивными реализациями, которые демонстрируют известную реакцию на запросы. Как правило, это значительно упрощает написание тестов и ускоряет их выполнение по сравнению с тестированием в реальной инфраструктуре приложения.

Процесс тестирование микросервисной архитектуры значительно отличается от обычного. Микросервисная архитектура — это совокупность небольших сервисов, где каждый из них обслуживает одну бизнес-задачу. В целом эти небольшие сервисы являются готовым приложением и решают основную задачу. 
Эти сервисы находятся на разных серверах и написаны на различных языках программирования, таких как Java и.Net. Однако, это также является и недостатком, поскольку разработчики определенного микросервиса практически не знают, что делают остальные микросервисы. Таким образом, это делает процесс тестирования не из легких. 

 Монолитные приложения чаще всего легче тестировать, поскольку при тестировании и отладке необходимо отслеживать только один репозиторий кода. С другой стороны, тестирование микросервисов является непростой задачей, потому что сервисы независимы и часто обмениваются данными между собой.
 Чтобы выяснить, как эффективно тестировать микросервисы, важно знать шесть основных тестов, которые должны выполнять группы разработчиков программного обеспечения, и общие инструменты, которые они могут использовать для реализации тестирования.

**Шесть основных тестов ПО**
Существует шесть основных типов тестирования, которые применимы также и к микросервисам.

_Unit-тест_. Проверяет наименьший фрагмент тестируемого программного кода, чтобы убедиться, что он работает правильно.

_Модульный тест_. Тестирует микросервисы в изолированной среде, при необходимости поддерживая фиктивные двойники, чтобы убедиться, что они соответствуют требованиям.

_Интеграционный тест_. Проверяет правильность работы связи и взаимодействия между компонентами.

_Контрактный тест_. Подтип интеграционного теста. Проверяет взаимодействия на границе внешней службы, чтобы убедиться, что она выполняет контракт, который ожидает потребляющая служба.

_Сквозной тест_. Гарантирует совместную работу всех компонентов, соответствие внешним требованиям и достижение намеченной функциональности.

_Тест производительности_. Гарантирует, что система обеспечивает высокую доступность, устойчивое потребление ресурсов и соответствующую балансировку рабочей нагрузки.
**Популярные инструменты тестирования микросервисов**

Существует множество инструментов для отслеживания, контроля и, при необходимости, корректировки работы и дизайна микросервисов. Собрали для вас основные инструменты тестирования микросервисов, обычно используемые в индустрии разработки.
_Gatling_ — это инструмент нагрузочного тестирования, написанный на Scala, который позволяет запускать симуляции на нескольких платформах. В конце моделирования Gatling автоматически сообщает такие показатели, как количество активных пользователей и время отклика. Обычно он используется для тестирования микросервисов и производительности веб-приложений.

_Hoverfly_  — это автоматизированный инструмент моделирования связи API с открытым исходным кодом, который помогает в интеграционном тестировании. Пользователь может проверить, как API реагируют на определенные события, такие как сетевая задержка и ограничение скорости. Он также выполняет тестовые вызовы между микрослужбами, имитируя связь, а затем фиксирует запросы и ответы в режиме прокси, чтобы убедиться, что они работают должным образом.

_Pact_ — это инструмент тестирования контрактов, который проверяет взаимодействие HTTP и сообщений, чтобы убедиться, что приложения работают правильно по контракту. По сути, службы-потребители определяют, как службы-поставщики должны предоставлять им необходимые данные. Предоставляющая услуга затем непрерывно тестирует, чтобы убедиться, что они соответствуют контрактам, предоставляя индивидуальную методологию тестирования, которая в идеале сокращает количество крупных модульных тестов.

_Vagrant от HashiCorp_ - инструмент виртуализации, который позволяет ИТ-командам создавать уникальные среды разработки программного обеспечения, тестировать сценарии управления инфраструктурой и отслеживать развертывания.
_VCR_ — это инструмент модульного тестирования, который перехватывает HTTP-вызовы. Он сохраняет эти вызовы и воспроизводит их в будущих тестах, чтобы ускорить процесс. Другой пример — WireMock, фиктивный HTTP-сервер, который можно использовать для записи и воспроизведения взаимодействий с API, создания ошибок, отслеживания задержек связи и имитации поведения с отслеживанием состояния.